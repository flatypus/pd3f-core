<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pd3f.doc_info API documentation</title>
<meta name="description" content="Statistics and information about document elements." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pd3f.doc_info</code></h1>
</header>
<section id="section-intro">
<p>Statistics and information about document elements.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Statistics and information about document elements.
&#34;&#34;&#34;

import logging
from collections import Counter
from statistics import median

from textdistance import jaccard
from cleantext import clean, fix_bad_unicode

from .dehyphen_wrapper import single_score
from .geometry import sim_bbox
from .utils import flatten

logger = logging.getLogger(__name__)


def avg_word_space(line):
    &#34;&#34;&#34;Average word space on a line, util for words / lines

    src: https://github.com/axa-group/Parsr/blob/69e6b9bf33f1cc43d5a87d428cedf1132ccc48e8/server/src/types/DocumentRepresentation/Paragraph.ts#L460
    &#34;&#34;&#34;

    def calc_margins(index, word):
        if index &gt; 0:
            return word[&#34;box&#34;][&#34;l&#34;] - (
                line[&#34;content&#34;][index - 1][&#34;box&#34;][&#34;l&#34;]
                + line[&#34;content&#34;][index - 1][&#34;box&#34;][&#34;w&#34;]
            )
        return 0

    margins = [calc_margins(i, w) for i, w in enumerate(line[&#34;content&#34;])]
    return sum(margins) / len(margins)


def roughly_same_font(f1, f2):
    # unreliable
    assert f1[&#34;sizeUnit&#34;] == &#34;px&#34;
    assert f2[&#34;sizeUnit&#34;] == &#34;px&#34;
    return abs(f1[&#34;size&#34;] - f2[&#34;size&#34;]) &lt; max(f1[&#34;size&#34;], f2[&#34;size&#34;]) * 0.2


def extract_elements(outer_element, element_type):
    def traverse(element):
        if type(element) is dict:
            if &#34;type&#34; in element and element[&#34;type&#34;] == element_type:
                return element
            if &#34;content&#34; in element:
                return traverse(element[&#34;content&#34;])
            return None
        if type(element) is list:
            return [traverse(e) for e in element]

    return [
        x for x in flatten(traverse(outer_element), keep_dict=True) if x is not None
    ]


def font_stats(outer_element):
    return [x[&#34;font&#34;] for x in extract_elements(outer_element, &#34;word&#34;)]


def most_used_font(element):
    return Counter(font_stats(element)).most_common(1)[0][0]


def get_lineheight(l1, l2):
    # l1 or l2 can be the upper line
    if l2[&#34;box&#34;][&#34;t&#34;] &lt; l1[&#34;box&#34;][&#34;t&#34;]:
        l1, l2 = l2, l1
    dif = l2[&#34;box&#34;][&#34;t&#34;] - l1[&#34;box&#34;][&#34;t&#34;] - l1[&#34;box&#34;][&#34;h&#34;]
    # it may happen that the lines are on the same
    return dif if dif &gt; 0 else None


def median_from_counter(c):
    data = []
    for value, count in c.most_common():
        data += [value] * count
    return median(data)


def only_text(es):
    r = []
    for e in es:
        for x in extract_elements(e, &#34;word&#34;):
            r.append(x[&#34;content&#34;].strip())
    return fix_bad_unicode(&#34; &#34;.join(r))


def only_points(es):
    r = []
    for e in es:
        b = e[&#34;box&#34;]
        r.append((b[&#34;t&#34;], b[&#34;l&#34;]))
        r.append((b[&#34;t&#34;] + b[&#34;h&#34;], b[&#34;l&#34;]))
        r.append((b[&#34;t&#34;], b[&#34;l&#34;] + b[&#34;w&#34;]))
        r.append((b[&#34;t&#34;] + b[&#34;h&#34;], b[&#34;l&#34;] + b[&#34;w&#34;]))
    return r


def super_similiar(es1, es2, sim_factor=0.8, sim_box=0.6):
    &#34;&#34;&#34;Check if two elements are super similiar by text (Jaccad) and visually (compare bbox).
    &#34;&#34;&#34;
    text1 = only_text(es1)
    text2 = only_text(es2)

    points1 = only_points(es1)
    points2 = only_points(es2)

    if min(len(points1), len(points2)) &lt; 4:
        return False

    logger.debug(&#34;points&#34;)
    logger.debug(points1)
    logger.debug(points2)

    j_sim = jaccard(text1, text2)
    b_sim = sim_bbox(points1, points2)

    logger.debug(f&#34;footer/header sims {j_sim} {b_sim}&#34;)

    return j_sim &gt; sim_factor and b_sim &gt; sim_box


def remove_duplicates(page_items, lang):
    results = [page_items[0]]
    for elements in page_items[1:]:
        cool = True
        for r in results:
            if len(r) == 0:
                continue
            # only choose the best first one?
            if super_similiar(r, elements):
                logger.debug(&#34;items are super similiar&#34;)
                if single_score(only_text(r), lang) &lt;= single_score(
                    only_text(elements), lang
                ):
                    logger.debug(
                        &#34;okay, skipping here, the previous one got better / same score&#34;
                    )
                    cool = False
                    break
                else:
                    logger.debug(&#34;removing previous one, this is better&#34;)
                    results.remove(r)

        if cool:
            results.append(elements)
        else:
            results.append([])
    return results


def remove_page_number_header_footer(page_items):
    &#34;&#34;&#34;Rough check to remove elements with text such as `Seite $NUM von $NUM` or just `$NUM`.

    TODO: Make it work if the pager number is part of a bigger header/footer. And also consider the language.
    &#34;&#34;&#34;
    texts = [
        clean(only_text(x), replace_with_number=&#34;&#34;, no_punct=True)
        .replace(&#34;seite&#34;, &#34;&#34;)
        .replace(&#34;von&#34;, &#34;&#34;)
        for x in page_items
    ]

    results = []
    for idx, x in enumerate(page_items):
        if texts[idx].strip() != &#34;&#34;:
            results.append(x)
    return results


def calc_line_space(lines):
    if len(lines) &lt;= 1:
        return []
    lineheights = []
    for i, _ in enumerate(lines[:-1]):
        if (x := get_lineheight(lines[i], lines[i + 1])) is not None:
            lineheights.append(x)
    return lineheights


class DocumentInfo:
    def __init__(self, input_data) -&gt; None:
        self.input_data = input_data

        # needs to be done first
        self.element_order_page()
        self.document_font_stats()
        self.document_paragraph_stats()

        # free memory (code should have been re-written but whatehver)
        del self.input_data

    def document_paragraph_stats(self):
        &#34;&#34;&#34;
        &#34;&#34;&#34;

        self.counter_width = Counter()
        self.counter_height = Counter()
        self.counter_lineheight = Counter()
        self.counter_line_left = Counter()

        for n_page, p in enumerate(self.input_data[&#34;pages&#34;]):
            for e in p[&#34;elements&#34;]:
                lis = extract_elements(e, &#34;line&#34;)
                for x in lis:
                    x[&#34;idx_page&#34;] = n_page
                    self.id_to_elem[x[&#34;id&#34;]] = x

                self.counter_width.update([x[&#34;box&#34;][&#34;w&#34;] for x in lis])
                self.counter_height.update([x[&#34;box&#34;][&#34;h&#34;] for x in lis])
                self.counter_lineheight.update(calc_line_space(lis))
                self.counter_line_left.update([x[&#34;box&#34;][&#34;l&#34;] for x in lis])

        if (
            min(
                map(
                    len,
                    [
                        self.counter_width,
                        self.counter_height,
                        self.counter_lineheight,
                        self.counter_line_left,
                    ],
                )
            )
            == 0
        ):
            raise ValueError(
                &#34;Something is wrong with the document. Is the text in the PDF broken (copy the text out of the doc and see how it looks)?&#34;
            )

        self.median_line_width = median_from_counter(self.counter_width)
        self.median_line_height = median_from_counter(self.counter_height)
        # line space: line height
        self.median_line_space = median_from_counter(self.counter_lineheight)
        self.median_line_left = median_from_counter(self.counter_line_left)

        logger.info(f&#34;media line width: {self.median_line_width}&#34;)
        logger.info(f&#34;median line height: {self.median_line_height}&#34;)
        logger.info(f&#34;median line space: {self.median_line_space}&#34;)
        logger.info(f&#34;counter width: {self.counter_width.most_common(5)}&#34;)
        logger.info(f&#34;counter height: {self.counter_height.most_common(5)}&#34;)
        logger.info(f&#34;counter lineheight: {self.counter_lineheight.most_common(5)}&#34;)

    def document_font_stats(self):
        &#34;&#34;&#34;Get statistics about font usage in the document
        &#34;&#34;&#34;
        c = Counter()
        for p in self.input_data[&#34;pages&#34;]:
            for e in p[&#34;elements&#34;]:
                c.update(font_stats(e))

        if len(c) == 0:
            raise ValueError(
                &#34;Something is wrong with the document. Is the text in the PDF broken (copy the text out of the doc and see how it looks)?&#34;
            )

        self.body_font = c.most_common(1)[0][0]
        self.font_counter = c
        self.font_info = {}
        for x in self.input_data[&#34;fonts&#34;]:
            self.font_info[x[&#34;id&#34;]] = x
            assert x[&#34;sizeUnit&#34;] == &#34;px&#34;

    def seperate_lines(self, l1, l2, factor=0.5):
        lh = get_lineheight(l1, l2)
        if lh is None:
            return False
        # space between lines can only be + 0.5x the body lineheight
        return ((lh - self.median_line_space) / self.median_line_space) &gt; factor

    def on_same_page(self, e1, e2):
        &#34;&#34;&#34;Check if both elements are on the same page
        &#34;&#34;&#34;
        return (
            self.id_to_elem[e1[&#34;id&#34;]][&#34;idx_page&#34;]
            == self.id_to_elem[e2[&#34;id&#34;]][&#34;idx_page&#34;]
        )

    def element_order_page(self):
        &#34;&#34;&#34;Save the order of paragraphes for each page, exclude header / footer
        &#34;&#34;&#34;
        self.order_page = []
        self.id_to_elem = {}
        for idx_page, p in enumerate(self.input_data[&#34;pages&#34;]):
            per_page = []
            for e in p[&#34;elements&#34;]:
                # not all elements are included here
                e[&#34;idx_page&#34;] = idx_page
                self.id_to_elem[e[&#34;id&#34;]] = e

                if not e[&#34;type&#34;] in (&#34;paragraph&#34;, &#34;heading&#34;):
                    continue
                if &#34;isHeader&#34; in e[&#34;properties&#34;] and e[&#34;properties&#34;][&#34;isHeader&#34;]:
                    continue
                if &#34;isFooter&#34; in e[&#34;properties&#34;] and e[&#34;properties&#34;][&#34;isFooter&#34;]:
                    continue

                per_page.append(e[&#34;id&#34;])
            self.order_page.append(per_page)

    def is_body_paragrah(self, para):
        lines = extract_elements(para, &#34;line&#34;)
        w_lines = [x[&#34;box&#34;][&#34;w&#34;] for x in lines]
        h_lines = [x[&#34;box&#34;][&#34;h&#34;] for x in lines]
        l_lines = [x[&#34;box&#34;][&#34;l&#34;] for x in lines]

        logger.debug(&#34;is it a body para?&#34;)
        if abs(self.median_line_width - max(w_lines)) &gt; 5:
            return False

        if abs(self.median_line_height - median(h_lines)) &gt; 2:
            return False

        if abs(self.median_line_left - median(l_lines)) &gt; 5:
            return False
        logger.debug(&#34;yes!&#34;)
        return True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pd3f.doc_info.avg_word_space"><code class="name flex">
<span>def <span class="ident">avg_word_space</span></span>(<span>line)</span>
</code></dt>
<dd>
<div class="desc"><p>Average word space on a line, util for words / lines</p>
<p>src: <a href="https://github.com/axa-group/Parsr/blob/69e6b9bf33f1cc43d5a87d428cedf1132ccc48e8/server/src/types/DocumentRepresentation/Paragraph.ts#L460">https://github.com/axa-group/Parsr/blob/69e6b9bf33f1cc43d5a87d428cedf1132ccc48e8/server/src/types/DocumentRepresentation/Paragraph.ts#L460</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def avg_word_space(line):
    &#34;&#34;&#34;Average word space on a line, util for words / lines

    src: https://github.com/axa-group/Parsr/blob/69e6b9bf33f1cc43d5a87d428cedf1132ccc48e8/server/src/types/DocumentRepresentation/Paragraph.ts#L460
    &#34;&#34;&#34;

    def calc_margins(index, word):
        if index &gt; 0:
            return word[&#34;box&#34;][&#34;l&#34;] - (
                line[&#34;content&#34;][index - 1][&#34;box&#34;][&#34;l&#34;]
                + line[&#34;content&#34;][index - 1][&#34;box&#34;][&#34;w&#34;]
            )
        return 0

    margins = [calc_margins(i, w) for i, w in enumerate(line[&#34;content&#34;])]
    return sum(margins) / len(margins)</code></pre>
</details>
</dd>
<dt id="pd3f.doc_info.calc_line_space"><code class="name flex">
<span>def <span class="ident">calc_line_space</span></span>(<span>lines)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_line_space(lines):
    if len(lines) &lt;= 1:
        return []
    lineheights = []
    for i, _ in enumerate(lines[:-1]):
        if (x := get_lineheight(lines[i], lines[i + 1])) is not None:
            lineheights.append(x)
    return lineheights</code></pre>
</details>
</dd>
<dt id="pd3f.doc_info.extract_elements"><code class="name flex">
<span>def <span class="ident">extract_elements</span></span>(<span>outer_element, element_type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_elements(outer_element, element_type):
    def traverse(element):
        if type(element) is dict:
            if &#34;type&#34; in element and element[&#34;type&#34;] == element_type:
                return element
            if &#34;content&#34; in element:
                return traverse(element[&#34;content&#34;])
            return None
        if type(element) is list:
            return [traverse(e) for e in element]

    return [
        x for x in flatten(traverse(outer_element), keep_dict=True) if x is not None
    ]</code></pre>
</details>
</dd>
<dt id="pd3f.doc_info.font_stats"><code class="name flex">
<span>def <span class="ident">font_stats</span></span>(<span>outer_element)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def font_stats(outer_element):
    return [x[&#34;font&#34;] for x in extract_elements(outer_element, &#34;word&#34;)]</code></pre>
</details>
</dd>
<dt id="pd3f.doc_info.get_lineheight"><code class="name flex">
<span>def <span class="ident">get_lineheight</span></span>(<span>l1, l2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_lineheight(l1, l2):
    # l1 or l2 can be the upper line
    if l2[&#34;box&#34;][&#34;t&#34;] &lt; l1[&#34;box&#34;][&#34;t&#34;]:
        l1, l2 = l2, l1
    dif = l2[&#34;box&#34;][&#34;t&#34;] - l1[&#34;box&#34;][&#34;t&#34;] - l1[&#34;box&#34;][&#34;h&#34;]
    # it may happen that the lines are on the same
    return dif if dif &gt; 0 else None</code></pre>
</details>
</dd>
<dt id="pd3f.doc_info.median_from_counter"><code class="name flex">
<span>def <span class="ident">median_from_counter</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def median_from_counter(c):
    data = []
    for value, count in c.most_common():
        data += [value] * count
    return median(data)</code></pre>
</details>
</dd>
<dt id="pd3f.doc_info.most_used_font"><code class="name flex">
<span>def <span class="ident">most_used_font</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def most_used_font(element):
    return Counter(font_stats(element)).most_common(1)[0][0]</code></pre>
</details>
</dd>
<dt id="pd3f.doc_info.only_points"><code class="name flex">
<span>def <span class="ident">only_points</span></span>(<span>es)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def only_points(es):
    r = []
    for e in es:
        b = e[&#34;box&#34;]
        r.append((b[&#34;t&#34;], b[&#34;l&#34;]))
        r.append((b[&#34;t&#34;] + b[&#34;h&#34;], b[&#34;l&#34;]))
        r.append((b[&#34;t&#34;], b[&#34;l&#34;] + b[&#34;w&#34;]))
        r.append((b[&#34;t&#34;] + b[&#34;h&#34;], b[&#34;l&#34;] + b[&#34;w&#34;]))
    return r</code></pre>
</details>
</dd>
<dt id="pd3f.doc_info.only_text"><code class="name flex">
<span>def <span class="ident">only_text</span></span>(<span>es)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def only_text(es):
    r = []
    for e in es:
        for x in extract_elements(e, &#34;word&#34;):
            r.append(x[&#34;content&#34;].strip())
    return fix_bad_unicode(&#34; &#34;.join(r))</code></pre>
</details>
</dd>
<dt id="pd3f.doc_info.remove_duplicates"><code class="name flex">
<span>def <span class="ident">remove_duplicates</span></span>(<span>page_items, lang)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_duplicates(page_items, lang):
    results = [page_items[0]]
    for elements in page_items[1:]:
        cool = True
        for r in results:
            if len(r) == 0:
                continue
            # only choose the best first one?
            if super_similiar(r, elements):
                logger.debug(&#34;items are super similiar&#34;)
                if single_score(only_text(r), lang) &lt;= single_score(
                    only_text(elements), lang
                ):
                    logger.debug(
                        &#34;okay, skipping here, the previous one got better / same score&#34;
                    )
                    cool = False
                    break
                else:
                    logger.debug(&#34;removing previous one, this is better&#34;)
                    results.remove(r)

        if cool:
            results.append(elements)
        else:
            results.append([])
    return results</code></pre>
</details>
</dd>
<dt id="pd3f.doc_info.remove_page_number_header_footer"><code class="name flex">
<span>def <span class="ident">remove_page_number_header_footer</span></span>(<span>page_items)</span>
</code></dt>
<dd>
<div class="desc"><p>Rough check to remove elements with text such as <code>Seite $NUM von $NUM</code> or just <code>$NUM</code>.</p>
<p>TODO: Make it work if the pager number is part of a bigger header/footer. And also consider the language.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_page_number_header_footer(page_items):
    &#34;&#34;&#34;Rough check to remove elements with text such as `Seite $NUM von $NUM` or just `$NUM`.

    TODO: Make it work if the pager number is part of a bigger header/footer. And also consider the language.
    &#34;&#34;&#34;
    texts = [
        clean(only_text(x), replace_with_number=&#34;&#34;, no_punct=True)
        .replace(&#34;seite&#34;, &#34;&#34;)
        .replace(&#34;von&#34;, &#34;&#34;)
        for x in page_items
    ]

    results = []
    for idx, x in enumerate(page_items):
        if texts[idx].strip() != &#34;&#34;:
            results.append(x)
    return results</code></pre>
</details>
</dd>
<dt id="pd3f.doc_info.roughly_same_font"><code class="name flex">
<span>def <span class="ident">roughly_same_font</span></span>(<span>f1, f2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def roughly_same_font(f1, f2):
    # unreliable
    assert f1[&#34;sizeUnit&#34;] == &#34;px&#34;
    assert f2[&#34;sizeUnit&#34;] == &#34;px&#34;
    return abs(f1[&#34;size&#34;] - f2[&#34;size&#34;]) &lt; max(f1[&#34;size&#34;], f2[&#34;size&#34;]) * 0.2</code></pre>
</details>
</dd>
<dt id="pd3f.doc_info.super_similiar"><code class="name flex">
<span>def <span class="ident">super_similiar</span></span>(<span>es1, es2, sim_factor=0.8, sim_box=0.6)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if two elements are super similiar by text (Jaccad) and visually (compare bbox).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def super_similiar(es1, es2, sim_factor=0.8, sim_box=0.6):
    &#34;&#34;&#34;Check if two elements are super similiar by text (Jaccad) and visually (compare bbox).
    &#34;&#34;&#34;
    text1 = only_text(es1)
    text2 = only_text(es2)

    points1 = only_points(es1)
    points2 = only_points(es2)

    if min(len(points1), len(points2)) &lt; 4:
        return False

    logger.debug(&#34;points&#34;)
    logger.debug(points1)
    logger.debug(points2)

    j_sim = jaccard(text1, text2)
    b_sim = sim_bbox(points1, points2)

    logger.debug(f&#34;footer/header sims {j_sim} {b_sim}&#34;)

    return j_sim &gt; sim_factor and b_sim &gt; sim_box</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pd3f.doc_info.DocumentInfo"><code class="flex name class">
<span>class <span class="ident">DocumentInfo</span></span>
<span>(</span><span>input_data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DocumentInfo:
    def __init__(self, input_data) -&gt; None:
        self.input_data = input_data

        # needs to be done first
        self.element_order_page()
        self.document_font_stats()
        self.document_paragraph_stats()

        # free memory (code should have been re-written but whatehver)
        del self.input_data

    def document_paragraph_stats(self):
        &#34;&#34;&#34;
        &#34;&#34;&#34;

        self.counter_width = Counter()
        self.counter_height = Counter()
        self.counter_lineheight = Counter()
        self.counter_line_left = Counter()

        for n_page, p in enumerate(self.input_data[&#34;pages&#34;]):
            for e in p[&#34;elements&#34;]:
                lis = extract_elements(e, &#34;line&#34;)
                for x in lis:
                    x[&#34;idx_page&#34;] = n_page
                    self.id_to_elem[x[&#34;id&#34;]] = x

                self.counter_width.update([x[&#34;box&#34;][&#34;w&#34;] for x in lis])
                self.counter_height.update([x[&#34;box&#34;][&#34;h&#34;] for x in lis])
                self.counter_lineheight.update(calc_line_space(lis))
                self.counter_line_left.update([x[&#34;box&#34;][&#34;l&#34;] for x in lis])

        if (
            min(
                map(
                    len,
                    [
                        self.counter_width,
                        self.counter_height,
                        self.counter_lineheight,
                        self.counter_line_left,
                    ],
                )
            )
            == 0
        ):
            raise ValueError(
                &#34;Something is wrong with the document. Is the text in the PDF broken (copy the text out of the doc and see how it looks)?&#34;
            )

        self.median_line_width = median_from_counter(self.counter_width)
        self.median_line_height = median_from_counter(self.counter_height)
        # line space: line height
        self.median_line_space = median_from_counter(self.counter_lineheight)
        self.median_line_left = median_from_counter(self.counter_line_left)

        logger.info(f&#34;media line width: {self.median_line_width}&#34;)
        logger.info(f&#34;median line height: {self.median_line_height}&#34;)
        logger.info(f&#34;median line space: {self.median_line_space}&#34;)
        logger.info(f&#34;counter width: {self.counter_width.most_common(5)}&#34;)
        logger.info(f&#34;counter height: {self.counter_height.most_common(5)}&#34;)
        logger.info(f&#34;counter lineheight: {self.counter_lineheight.most_common(5)}&#34;)

    def document_font_stats(self):
        &#34;&#34;&#34;Get statistics about font usage in the document
        &#34;&#34;&#34;
        c = Counter()
        for p in self.input_data[&#34;pages&#34;]:
            for e in p[&#34;elements&#34;]:
                c.update(font_stats(e))

        if len(c) == 0:
            raise ValueError(
                &#34;Something is wrong with the document. Is the text in the PDF broken (copy the text out of the doc and see how it looks)?&#34;
            )

        self.body_font = c.most_common(1)[0][0]
        self.font_counter = c
        self.font_info = {}
        for x in self.input_data[&#34;fonts&#34;]:
            self.font_info[x[&#34;id&#34;]] = x
            assert x[&#34;sizeUnit&#34;] == &#34;px&#34;

    def seperate_lines(self, l1, l2, factor=0.5):
        lh = get_lineheight(l1, l2)
        if lh is None:
            return False
        # space between lines can only be + 0.5x the body lineheight
        return ((lh - self.median_line_space) / self.median_line_space) &gt; factor

    def on_same_page(self, e1, e2):
        &#34;&#34;&#34;Check if both elements are on the same page
        &#34;&#34;&#34;
        return (
            self.id_to_elem[e1[&#34;id&#34;]][&#34;idx_page&#34;]
            == self.id_to_elem[e2[&#34;id&#34;]][&#34;idx_page&#34;]
        )

    def element_order_page(self):
        &#34;&#34;&#34;Save the order of paragraphes for each page, exclude header / footer
        &#34;&#34;&#34;
        self.order_page = []
        self.id_to_elem = {}
        for idx_page, p in enumerate(self.input_data[&#34;pages&#34;]):
            per_page = []
            for e in p[&#34;elements&#34;]:
                # not all elements are included here
                e[&#34;idx_page&#34;] = idx_page
                self.id_to_elem[e[&#34;id&#34;]] = e

                if not e[&#34;type&#34;] in (&#34;paragraph&#34;, &#34;heading&#34;):
                    continue
                if &#34;isHeader&#34; in e[&#34;properties&#34;] and e[&#34;properties&#34;][&#34;isHeader&#34;]:
                    continue
                if &#34;isFooter&#34; in e[&#34;properties&#34;] and e[&#34;properties&#34;][&#34;isFooter&#34;]:
                    continue

                per_page.append(e[&#34;id&#34;])
            self.order_page.append(per_page)

    def is_body_paragrah(self, para):
        lines = extract_elements(para, &#34;line&#34;)
        w_lines = [x[&#34;box&#34;][&#34;w&#34;] for x in lines]
        h_lines = [x[&#34;box&#34;][&#34;h&#34;] for x in lines]
        l_lines = [x[&#34;box&#34;][&#34;l&#34;] for x in lines]

        logger.debug(&#34;is it a body para?&#34;)
        if abs(self.median_line_width - max(w_lines)) &gt; 5:
            return False

        if abs(self.median_line_height - median(h_lines)) &gt; 2:
            return False

        if abs(self.median_line_left - median(l_lines)) &gt; 5:
            return False
        logger.debug(&#34;yes!&#34;)
        return True</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pd3f.doc_info.DocumentInfo.document_font_stats"><code class="name flex">
<span>def <span class="ident">document_font_stats</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get statistics about font usage in the document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def document_font_stats(self):
    &#34;&#34;&#34;Get statistics about font usage in the document
    &#34;&#34;&#34;
    c = Counter()
    for p in self.input_data[&#34;pages&#34;]:
        for e in p[&#34;elements&#34;]:
            c.update(font_stats(e))

    if len(c) == 0:
        raise ValueError(
            &#34;Something is wrong with the document. Is the text in the PDF broken (copy the text out of the doc and see how it looks)?&#34;
        )

    self.body_font = c.most_common(1)[0][0]
    self.font_counter = c
    self.font_info = {}
    for x in self.input_data[&#34;fonts&#34;]:
        self.font_info[x[&#34;id&#34;]] = x
        assert x[&#34;sizeUnit&#34;] == &#34;px&#34;</code></pre>
</details>
</dd>
<dt id="pd3f.doc_info.DocumentInfo.document_paragraph_stats"><code class="name flex">
<span>def <span class="ident">document_paragraph_stats</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def document_paragraph_stats(self):
    &#34;&#34;&#34;
    &#34;&#34;&#34;

    self.counter_width = Counter()
    self.counter_height = Counter()
    self.counter_lineheight = Counter()
    self.counter_line_left = Counter()

    for n_page, p in enumerate(self.input_data[&#34;pages&#34;]):
        for e in p[&#34;elements&#34;]:
            lis = extract_elements(e, &#34;line&#34;)
            for x in lis:
                x[&#34;idx_page&#34;] = n_page
                self.id_to_elem[x[&#34;id&#34;]] = x

            self.counter_width.update([x[&#34;box&#34;][&#34;w&#34;] for x in lis])
            self.counter_height.update([x[&#34;box&#34;][&#34;h&#34;] for x in lis])
            self.counter_lineheight.update(calc_line_space(lis))
            self.counter_line_left.update([x[&#34;box&#34;][&#34;l&#34;] for x in lis])

    if (
        min(
            map(
                len,
                [
                    self.counter_width,
                    self.counter_height,
                    self.counter_lineheight,
                    self.counter_line_left,
                ],
            )
        )
        == 0
    ):
        raise ValueError(
            &#34;Something is wrong with the document. Is the text in the PDF broken (copy the text out of the doc and see how it looks)?&#34;
        )

    self.median_line_width = median_from_counter(self.counter_width)
    self.median_line_height = median_from_counter(self.counter_height)
    # line space: line height
    self.median_line_space = median_from_counter(self.counter_lineheight)
    self.median_line_left = median_from_counter(self.counter_line_left)

    logger.info(f&#34;media line width: {self.median_line_width}&#34;)
    logger.info(f&#34;median line height: {self.median_line_height}&#34;)
    logger.info(f&#34;median line space: {self.median_line_space}&#34;)
    logger.info(f&#34;counter width: {self.counter_width.most_common(5)}&#34;)
    logger.info(f&#34;counter height: {self.counter_height.most_common(5)}&#34;)
    logger.info(f&#34;counter lineheight: {self.counter_lineheight.most_common(5)}&#34;)</code></pre>
</details>
</dd>
<dt id="pd3f.doc_info.DocumentInfo.element_order_page"><code class="name flex">
<span>def <span class="ident">element_order_page</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the order of paragraphes for each page, exclude header / footer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def element_order_page(self):
    &#34;&#34;&#34;Save the order of paragraphes for each page, exclude header / footer
    &#34;&#34;&#34;
    self.order_page = []
    self.id_to_elem = {}
    for idx_page, p in enumerate(self.input_data[&#34;pages&#34;]):
        per_page = []
        for e in p[&#34;elements&#34;]:
            # not all elements are included here
            e[&#34;idx_page&#34;] = idx_page
            self.id_to_elem[e[&#34;id&#34;]] = e

            if not e[&#34;type&#34;] in (&#34;paragraph&#34;, &#34;heading&#34;):
                continue
            if &#34;isHeader&#34; in e[&#34;properties&#34;] and e[&#34;properties&#34;][&#34;isHeader&#34;]:
                continue
            if &#34;isFooter&#34; in e[&#34;properties&#34;] and e[&#34;properties&#34;][&#34;isFooter&#34;]:
                continue

            per_page.append(e[&#34;id&#34;])
        self.order_page.append(per_page)</code></pre>
</details>
</dd>
<dt id="pd3f.doc_info.DocumentInfo.is_body_paragrah"><code class="name flex">
<span>def <span class="ident">is_body_paragrah</span></span>(<span>self, para)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_body_paragrah(self, para):
    lines = extract_elements(para, &#34;line&#34;)
    w_lines = [x[&#34;box&#34;][&#34;w&#34;] for x in lines]
    h_lines = [x[&#34;box&#34;][&#34;h&#34;] for x in lines]
    l_lines = [x[&#34;box&#34;][&#34;l&#34;] for x in lines]

    logger.debug(&#34;is it a body para?&#34;)
    if abs(self.median_line_width - max(w_lines)) &gt; 5:
        return False

    if abs(self.median_line_height - median(h_lines)) &gt; 2:
        return False

    if abs(self.median_line_left - median(l_lines)) &gt; 5:
        return False
    logger.debug(&#34;yes!&#34;)
    return True</code></pre>
</details>
</dd>
<dt id="pd3f.doc_info.DocumentInfo.on_same_page"><code class="name flex">
<span>def <span class="ident">on_same_page</span></span>(<span>self, e1, e2)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if both elements are on the same page</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_same_page(self, e1, e2):
    &#34;&#34;&#34;Check if both elements are on the same page
    &#34;&#34;&#34;
    return (
        self.id_to_elem[e1[&#34;id&#34;]][&#34;idx_page&#34;]
        == self.id_to_elem[e2[&#34;id&#34;]][&#34;idx_page&#34;]
    )</code></pre>
</details>
</dd>
<dt id="pd3f.doc_info.DocumentInfo.seperate_lines"><code class="name flex">
<span>def <span class="ident">seperate_lines</span></span>(<span>self, l1, l2, factor=0.5)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def seperate_lines(self, l1, l2, factor=0.5):
    lh = get_lineheight(l1, l2)
    if lh is None:
        return False
    # space between lines can only be + 0.5x the body lineheight
    return ((lh - self.median_line_space) / self.median_line_space) &gt; factor</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pd3f" href="index.html">pd3f</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pd3f.doc_info.avg_word_space" href="#pd3f.doc_info.avg_word_space">avg_word_space</a></code></li>
<li><code><a title="pd3f.doc_info.calc_line_space" href="#pd3f.doc_info.calc_line_space">calc_line_space</a></code></li>
<li><code><a title="pd3f.doc_info.extract_elements" href="#pd3f.doc_info.extract_elements">extract_elements</a></code></li>
<li><code><a title="pd3f.doc_info.font_stats" href="#pd3f.doc_info.font_stats">font_stats</a></code></li>
<li><code><a title="pd3f.doc_info.get_lineheight" href="#pd3f.doc_info.get_lineheight">get_lineheight</a></code></li>
<li><code><a title="pd3f.doc_info.median_from_counter" href="#pd3f.doc_info.median_from_counter">median_from_counter</a></code></li>
<li><code><a title="pd3f.doc_info.most_used_font" href="#pd3f.doc_info.most_used_font">most_used_font</a></code></li>
<li><code><a title="pd3f.doc_info.only_points" href="#pd3f.doc_info.only_points">only_points</a></code></li>
<li><code><a title="pd3f.doc_info.only_text" href="#pd3f.doc_info.only_text">only_text</a></code></li>
<li><code><a title="pd3f.doc_info.remove_duplicates" href="#pd3f.doc_info.remove_duplicates">remove_duplicates</a></code></li>
<li><code><a title="pd3f.doc_info.remove_page_number_header_footer" href="#pd3f.doc_info.remove_page_number_header_footer">remove_page_number_header_footer</a></code></li>
<li><code><a title="pd3f.doc_info.roughly_same_font" href="#pd3f.doc_info.roughly_same_font">roughly_same_font</a></code></li>
<li><code><a title="pd3f.doc_info.super_similiar" href="#pd3f.doc_info.super_similiar">super_similiar</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pd3f.doc_info.DocumentInfo" href="#pd3f.doc_info.DocumentInfo">DocumentInfo</a></code></h4>
<ul class="">
<li><code><a title="pd3f.doc_info.DocumentInfo.document_font_stats" href="#pd3f.doc_info.DocumentInfo.document_font_stats">document_font_stats</a></code></li>
<li><code><a title="pd3f.doc_info.DocumentInfo.document_paragraph_stats" href="#pd3f.doc_info.DocumentInfo.document_paragraph_stats">document_paragraph_stats</a></code></li>
<li><code><a title="pd3f.doc_info.DocumentInfo.element_order_page" href="#pd3f.doc_info.DocumentInfo.element_order_page">element_order_page</a></code></li>
<li><code><a title="pd3f.doc_info.DocumentInfo.is_body_paragrah" href="#pd3f.doc_info.DocumentInfo.is_body_paragrah">is_body_paragrah</a></code></li>
<li><code><a title="pd3f.doc_info.DocumentInfo.on_same_page" href="#pd3f.doc_info.DocumentInfo.on_same_page">on_same_page</a></code></li>
<li><code><a title="pd3f.doc_info.DocumentInfo.seperate_lines" href="#pd3f.doc_info.DocumentInfo.seperate_lines">seperate_lines</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>